# Vectors and Matrices: The Heart of MATLAB

MATLAB was built for matrix operations. Every signal in DSP is a vector (a sequence of samples).

### Creating Vectors

```bash filename="vectors.m" copy
% Row vector (1×N matrix): samples arranged horizontally
row_signal = [1, 2, 3, 4, 5];  % Or: [1 2 3 4 5]

% Column vector (N×1 matrix): samples arranged vertically
column_signal = [1; 2; 3; 4; 5];

% Transpose operator (') converts row to column or vice versa
column_from_row = row_signal';

% Colon operator: start:step:end
time_vector = 0:0.1:1;     % 0, 0.1, 0.2, ..., 1.0 (11 elements)
fs = 8000;                  % Sampling frequency
duration = 1;               % 1 second
t = 0:1/fs:duration-1/fs;  % Standard time vector for 1 second at 8 kHz

% linspace: linearly spaced vector (you specify number of points, not step)
freq_axis = linspace(0, 4000, 1000); % 1000 points from 0 to 4000 Hz
phase_angles = linspace(0, 2*pi, 100); % 100 points from 0 to 2π

% logspace: logarithmically spaced (useful for frequency plots)
log_freq = logspace(0, 5, 100); % 100 points from 10^0 to 10^5 Hz (1 to 100 kHz)
```

**Explanation**: The colon operator `start:step:end` is fundamental in DSP. For a 1-second signal at 8 kHz, you need 8000 samples, so `0:1/fs:duration-1/fs` creates exactly that. `linspace` is easier when you know the number of points but not the step size. `logspace` creates points on a logarithmic scale, useful for frequency responses that span many decades.

### Indexing and Slicing Vectors

```bash filename="vectors.m" copy
signal = [10, 20, 30, 40, 50, 60];

% Single element (MATLAB uses 1-based indexing, not 0-like Python)
first_sample = signal(1);   % 10
third_sample = signal(3);   % 30
last_sample = signal(end);  % 60

% Range of elements
first_three = signal(1:3);         % [10, 20, 30]
last_two = signal(end-1:end);      % [50, 60]
every_other = signal(1:2:end);     % [10, 30, 50] — step size is 2

% Conditional indexing (returns samples matching a condition)
large_samples = signal(signal > 25);  % [30, 40, 50, 60]
```

**Explanation**: MATLAB indexing starts at 1 (not 0). The `end` keyword gives the last index. The range `1:3` means indices 1, 2, and 3. The step in `1:2:end` means every 2nd element. Conditional indexing `signal(signal > 25)` returns only samples greater than 25—essential for signal processing.

### Matrix Operations

```bash filename="vectors.m" copy
clear all; clc;

A = [1, 2; 3, 4];   % 2×2 matrix
B = [5, 6; 7, 8];   % 2×2 matrix
v = [1; 2];         % 2×1 column vector

% Matrix multiplication (standard algebra)
C = A * B;          % Matrix product: (2×2) × (2×2) = (2×2)
result = A * v;     % Matrix-vector product: (2×2) × (2×1) = (2×1)

% Element-wise multiplication (each element of A times corresponding element of B)
element_wise = A .* B;  % Note the dot before *

% For vectors, * performs dot product (scalar result)
v1 = [1, 2, 3];
v2 = [4, 5, 6];
dot_product = v1 * v2';  % [1 2 3] × [4; 5; 6] = 1×4 + 2×5 + 3×6 = 32

% Dimensions of a matrix
size_matrix = size(A);   % Returns [2, 2]
num_rows = size(A, 1);   % Returns 2
num_cols = size(A, 2);   % Returns 2
length_vector = length(v); % Returns 2 (works for vectors)
```

**Explanation**: This is critical for DSP. Matrix multiplication `A * B` follows linear algebra rules. Element-wise operations use the dot operator (`.* ./ .^`). For convolution and filtering, you'll use matrix operations constantly. A 1×N row vector times an N×1 column vector gives a scalar (dot product), which is exactly how you compute filtered outputs.