# Loops: for and while

Loops automate repetitive calculations—essential when processing long signals or designing filters.

### For Loop

For loops are used when you know the number of iterations.

```bash filename="loops.m" copy
clear all; clc;

% Generate 5 sine waves at different frequencies
fs = 1000;           % 1 kHz sampling
t = 0:1/fs:1;        % 1 second of samples
frequencies = [100, 200, 300, 400, 500];  % Hz

signals = [];        % Initialize empty array

for idx = 1:length(frequencies)
    f = frequencies(idx);
    signal = sin(2*pi*f*t);
    signals = [signals; signal];  % Append signal as new row
end

% signals is now a 5×1000 matrix: 5 signals, 1000 samples each
disp(['Generated ', num2str(size(signals, 1)), ' signals']);
```

**Explanation**: `for idx = 1:5` loops 5 times with `idx` taking values 1, 2, 3, 4, 5. Inside the loop, `frequencies(idx)` accesses the idx-th frequency. We build the `signals` matrix by appending rows. In professional code, you'd pre-allocate the matrix instead:

```bash filename="loops.m" copy
% More efficient pre-allocation
signals = zeros(length(frequencies), length(t));  % Pre-allocate

for idx = 1:length(frequencies)
    f = frequencies(idx);
    signals(idx, :) = sin(2*pi*f*t);  % Fill the idx-th row
end
```

**Explanation**: Pre-allocation is faster because MATLAB doesn't have to resize the array each iteration. `zeros(5, 1000)` creates a 5×1000 matrix of zeros. We then fill each row `signals(idx, :)` with the sine wave.

### While Loop
While Loop is being used when you don't know the number of iterations.

```bash filename="loops.m" copy
clear all; clc;

% Detect signal level until it drops below threshold
signal = [0.1, 0.3, 0.5, 0.7, 0.9, 0.8, 0.6, 0.4, 0.2];
idx = 1;
threshold = 0.5;

while signal(idx) < threshold && idx < length(signal)
    idx = idx + 1;
end

if idx <= length(signal)
    disp(['Signal exceeds threshold at sample ', num2str(idx)]);
else
    disp('Signal never exceeds threshold');
end
```

**Explanation**: The while loop continues as long as the condition is true. Here, we increment `idx` until either the signal exceeds the threshold or we reach the end. The `&&` ensures we don't access beyond the signal length.